// src/tasks/tasks.service.ts
import {
  Injectable,
  NotFoundException,
  BadRequestException,
} from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { CreateTaskDto, TaskStatus } from './dto/create-task.dto';
import { UpdateTaskDto } from './dto/update-task.dto';
import { User } from 'src/users/entities/user.schema';
import { Project } from 'src/projects/entities/project.schema';
import { Task } from './entities/task.entity';


@Injectable()
export class TaskService {
  constructor(
    @InjectModel(Task.name) private readonly taskModel: Model<Task>,
    @InjectModel(Project.name) private readonly projectModel: Model<Project>,
    @InjectModel(User.name) private readonly userModel: Model<User>, // Inject User model for validation
  ) {}

  /**
   * Create a new task.
   * @param createTaskDto - Data Transfer Object containing task details.
   * @returns The created Task document.
   */
  async createTask(createTaskDto: CreateTaskDto): Promise<Task> {
    const {
      title,
      description,
      deadline,
      budget,
      status,
      projectId,
      members,
    } = createTaskDto;

    // Validate projectId
    if (!Types.ObjectId.isValid(projectId)) {
      throw new BadRequestException('Invalid Project ID format.');
    }
    const projectObjectId = new Types.ObjectId(projectId);

    // Validate that project exists
    const project = await this.projectModel.findById(projectObjectId).exec();
    if (!project) {
      throw new NotFoundException(`Project with ID ${projectId} not found.`);
    }

    // Validate that all members exist
    const memberObjectIds = members.map((id) => new Types.ObjectId(id));
    const existingMembers = await this.userModel.find({
      _id: { $in: memberObjectIds },
    }).exec();
    if (existingMembers.length !== memberObjectIds.length) {
      throw new BadRequestException('One or more members do not exist.');
    }

    // Create the task
    const task = new this.taskModel({
      title,
      description,
      deadline,
      budget,
      status,
      projectId: projectObjectId,
      members: memberObjectIds,
      // taskId is automatically generated by the schema if needed
    });

    const savedTask = await task.save();

    // **Optional:** If not using pre-save hooks, manually add task to project's tasks array
    // await this.projectModel.findByIdAndUpdate(projectObjectId, {
    //   $push: { tasks: savedTask._id },
    // }).exec();

    return savedTask;
  }

  /**
   * Retrieve all tasks.
   * @returns An array of Task documents.
   */
  async getAllTasks(): Promise<Task[]> {
    return this.taskModel.find().exec(); // Optionally, use populate to fetch related data
  }

  /**
   * Retrieve a task by its MongoDB ObjectId.
   * @param id - The MongoDB ObjectId of the task.
   * @returns The Task document.
   * @throws NotFoundException if the task is not found.
   */
  async getTaskById(id: string): Promise<Task> {
    if (!Types.ObjectId.isValid(id)) {
      throw new BadRequestException('Invalid Task ID format.');
    }

    const task = await this.taskModel.findById(id).exec(); // Optionally, use populate
    if (!task) {
      throw new NotFoundException(`Task with ID ${id} not found.`);
    }
    return task;
  }

  /**
   * Retrieve tasks associated with a specific project.
   * @param projectId - The MongoDB ObjectId of the project.
   * @returns An array of Task documents.
   * @throws BadRequestException if the projectId format is invalid.
   */
  async findByProject(projectId: string): Promise<Task[]> {
    if (!Types.ObjectId.isValid(projectId)) {
      throw new BadRequestException('Invalid Project ID format.');
    }
    const objectId = new Types.ObjectId(projectId);
    return this.taskModel.find({ projectId: objectId }).exec(); // Optionally, use populate
  }

  /**
   * Update a task by its MongoDB ObjectId.
   * @param id - The MongoDB ObjectId of the task.
   * @param updateTaskDto - Data Transfer Object containing fields to update.
   * @returns The updated Task document.
   * @throws NotFoundException if the task is not found.
   */
  async updateTask(
    id: string,
    updateTaskDto: UpdateTaskDto,
  ): Promise<Task> {
    if (!Types.ObjectId.isValid(id)) {
      throw new BadRequestException('Invalid Task ID format.');
    }

    // If projectId is being updated, validate it
    if (updateTaskDto.projectId) {
      if (!Types.ObjectId.isValid(updateTaskDto.projectId)) {
        throw new BadRequestException('Invalid Project ID format.');
      }
      const project = await this.projectModel.findById(updateTaskDto.projectId).exec();
      if (!project) {
        throw new NotFoundException(
          `Project with ID ${updateTaskDto.projectId} not found.`,
        );
      }
    }

    // If members are being updated, validate them
    if (updateTaskDto.members) {
      const memberObjectIds = updateTaskDto.members.map(
        (id) => new Types.ObjectId(id),
      );
      const existingMembers = await this.userModel.find({
        _id: { $in: memberObjectIds },
      }).exec();
      if (existingMembers.length !== memberObjectIds.length) {
        throw new BadRequestException('One or more members do not exist.');
      }
      // Convert ObjectIds back to strings if necessary
      updateTaskDto.members = memberObjectIds.map((id) => id.toHexString());
    }

    // If status is being updated, ensure it's a valid enum value
    if (updateTaskDto.status) {
      const validStatuses = Object.values(TaskStatus);
      if (!validStatuses.includes(updateTaskDto.status)) {
        throw new BadRequestException(
          `Invalid status value. Allowed values are: ${validStatuses.join(', ')}`,
        );
      }
    }

    const updatedTask = await this.taskModel
      .findByIdAndUpdate(
        id,
        { $set: updateTaskDto },
        { new: true, runValidators: true },
      )
      .populate('projectId', 'name') // Optionally populate project name
      .populate('members', 'username') // Optionally populate member usernames
      .exec();

    if (!updatedTask) {
      throw new NotFoundException(`Task with ID ${id} not found.`);
    }

    return updatedTask;
  }

  /**
   * Delete a task by its MongoDB ObjectId.
   * @param id - The MongoDB ObjectId of the task.
   * @returns A confirmation message.
   * @throws NotFoundException if the task is not found.
   */
  async deleteTask(id: string): Promise<{ message: string }> {
    if (!Types.ObjectId.isValid(id)) {
      throw new BadRequestException('Invalid Task ID format.');
    }

    const task = await this.taskModel.findById(id).exec();
    if (!task) {
      throw new NotFoundException(`Task with ID ${id} not found.`);
    }

  

    return { message: 'Task deleted successfully.' };
  }

  /**
   * Update the status of a task by its unique taskId.
   * This method is used by the webhook to update task statuses based on commit messages.
   * @param taskId - The unique identifier of the task.
   * @param update - An object containing the status to update.
   * @returns The updated Task document.
   * @throws NotFoundException if the task is not found.
   * @throws BadRequestException if the taskId or status is invalid.
   */
  async updateTaskStatusByTaskId(
    taskId: string,
    update: { status: string },
  ): Promise<Task> {
    if (!taskId) {
      throw new BadRequestException('Task ID must be provided.');
    }

    // Validate the status value against TaskStatus enum
    const validStatuses = Object.values(TaskStatus);
    const formattedStatus = update.status.toUpperCase();

    if (!validStatuses.includes(formattedStatus as TaskStatus)) {
      throw new BadRequestException(
        `Invalid status value. Allowed values are: ${validStatuses.join(', ')}`,
      );
    }

    const updatedTask = await this.taskModel.findOneAndUpdate(
      { taskId },
      { status: formattedStatus },
      { new: true, runValidators: true },
    ).exec();

    if (!updatedTask) {
      throw new NotFoundException(`Task with ID ${taskId} not found.`);
    }

    return updatedTask;
  }

  /**
   * Find a task by its unique taskId.
   * @param taskId - The unique identifier of the task.
   * @returns The Task document.
   * @throws NotFoundException if the task is not found.
   */
  async findByTaskId(taskId: string): Promise<Task> {
    if (!taskId) {
      throw new BadRequestException('Task ID must be provided.');
    }

    const task = await this.taskModel.findOne({ taskId }).exec();
    if (!task) {
      throw new NotFoundException(`Task with ID ${taskId} not found.`);
    }
    return task;
  }
}
